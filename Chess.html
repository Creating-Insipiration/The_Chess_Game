<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Cartoon Chess</title>
    <!-- Favicon: A simple chess knight icon -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>♘</text></svg>">
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Tone.js for audio synthesis -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <style>
        /* Custom styles for the game */
        :root {
            --white-square: #EAE8E5;
            --black-square: #D9CCC8;
            --white-piece: #BA9B79;
            --black-piece: #9E6850;
            --move-dot: rgba(102, 205, 170, 0.7); /* Light Aqua Blue with transparency */
            --font-family: 'Comic Sans MS', 'Chalkboard SE', 'Marker Felt', sans-serif;
        }

        body {
            font-family: var(--font-family);
            touch-action: manipulation; /* Disables double-tap to zoom on mobile */
        }

        /* Center the game board and ensure it fits the screen */
        .game-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: #f0e9e1;
        }
        
        #chessboard {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            width: 95vw;
            max-width: 600px;
            height: 95vw;
            max-height: 600px;
            border: 8px solid #b49d85;
            border-radius: 12px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
        }

        .square {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .piece {
            width: 85%;
            height: 85%;
            cursor: pointer;
            position: absolute;
            transition: transform 0.3s ease-in-out;
            z-index: 10;
        }

        /* Style for the dots indicating valid moves */
        .move-dot {
            width: 40%;
            height: 40%;
            background-color: var(--move-dot);
            border-radius: 50%;
            pointer-events: none; /* Allows clicks to pass through to the square */
            z-index: 5;
        }

        .selected {
            filter: drop-shadow(0 0 8px rgba(255, 223, 0, 0.9));
        }
        
        .in-check {
             animation: pulse-red 1.2s infinite;
        }

        @keyframes pulse-red {
            0% { box-shadow: 0 0 0 0 rgba(255, 82, 82, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(255, 82, 82, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 82, 82, 0); }
        }

    </style>
</head>
<body class="bg-gray-200">

<div id="game-container" class="game-container">
    <div id="turn-indicator" class="text-2xl font-bold mb-2" style="color: var(--black-piece);">White's Turn</div>
    <div id="chessboard"></div>
    <div id="check-indicator" class="text-xl font-bold mt-2 text-red-600 h-8"></div>
</div>

<!-- Modal for winning message -->
<div id="win-modal" class="hidden fixed inset-0 bg-black bg-opacity-60 flex justify-center items-center z-50">
    <div class="bg-white p-8 rounded-2xl shadow-2xl text-center transform scale-90 transition-transform duration-300">
        <h2 id="win-message" class="text-4xl font-extrabold mb-4" style="color: #6a4f4b;">Congratulations!</h2>
        <img id="win-image" src="https://placehold.co/300x200/EAE8E5/9E6850?text=🏆" alt="Winner Trophy" class="mx-auto rounded-lg mb-6 shadow-lg">
        <button onclick="resetGame()" class="bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-8 rounded-full text-xl transition-transform transform hover:scale-105">
            Play Again
        </button>
    </div>
</div>


<script type="module">
    // --- Board and Piece Colors ---
    const colors = {
        whiteSquare: 'var(--white-square)',
        blackSquare: 'var(--black-square)',
        whitePiece: 'var(--white-piece)',
        blackPiece: 'var(--black-piece)',
    };
    
    // --- DOM Elements ---
    const boardElement = document.getElementById('chessboard');
    const turnIndicator = document.getElementById('turn-indicator');
    const checkIndicator = document.getElementById('check-indicator');
    const winModal = document.getElementById('win-modal');
    const winMessage = document.getElementById('win-message');

    // --- Game State ---
    let boardState = [];
    let currentPlayer = 'white';
    let selectedPiece = null;
    let validMoves = [];
    let isGameOver = false;
    let whiteKingPosition = { row: 7, col: 4 };
    let blackKingPosition = { row: 0, col: 4 };

    // --- Audio Synthesis Setup (Tone.js) ---
    // Using simple synths to avoid external file dependencies
    const moveSound = new Tone.Synth({
        oscillator: { type: 'sine' },
        envelope: { attack: 0.005, decay: 0.1, sustain: 0.05, release: 0.1 }
    }).toDestination();

    const captureSound = new Tone.Synth({
        oscillator: { type: 'triangle' },
        envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.2 }
    }).toDestination();

    const checkSound = new Tone.MonoSynth({
        oscillator: { type: "sawtooth" },
        envelope: { attack: 0.01, decay: 0.1, sustain: 0.2, release: 0.3 },
        filterEnvelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.2, baseFrequency: 400, octaves: 4 }
    }).toDestination();
    
    // --- Piece SVG Definitions (Cartoonish Style) ---
    const pieceSVG = {
        'w_pawn': `<svg viewBox="0 0 100 100"><g fill="${colors.whitePiece}" stroke="${colors.blackPiece}" stroke-width="3"><circle cx="50" cy="30" r="20" /><rect x="35" y="45" width="30" height="40" rx="10" /><rect x="25" y="80" width="50" height="10" rx="5" /></g></svg>`,
        'w_rook': `<svg viewBox="0 0 100 100"><g fill="${colors.whitePiece}" stroke="${colors.blackPiece}" stroke-width="3"><rect x="25" y="20" width="50" height="15" rx="5" /><rect x="35" y="35" width="30" height="50" rx="5" /><rect x="20" y="80" width="60" height="10" rx="5" /></g></svg>`,
        'w_knight': `<svg viewBox="0 0 100 100"><g fill="${colors.whitePiece}" stroke="${colors.blackPiece}" stroke-width="3"><path d="M 40 20 C 20 20, 20 60, 40 60 L 50 80 L 30 80 L 25 90 L 75 90 L 70 80 L 50 80 L 60 50 C 80 50, 80 20, 60 20 Z" /><circle cx="60" cy="35" r="5" fill="${colors.blackPiece}"/></g></svg>`,
        'w_bishop': `<svg viewBox="0 0 100 100"><g fill="${colors.whitePiece}" stroke="${colors.blackPiece}" stroke-width="3"><path d="M 50 15 A 25 25 0 0 1 50 65 A 25 25 0 0 1 50 15 Z" /><rect x="40" y="60" width="20" height="25" rx="5" /><rect x="30" y="80" width="40" height="10" rx="5" /></g></svg>`,
        'w_queen': `<svg viewBox="0 0 100 100"><g fill="${colors.whitePiece}" stroke="${colors.blackPiece}" stroke-width="3"><circle cx="50" cy="20" r="10" /><path d="M 30 30 L 70 30 L 60 70 L 40 70 Z" /><rect x="35" y="70" width="30" height="15" rx="5" /><rect x="25" y="85" width="50" height="10" rx="5" /></g></svg>`,
        'w_king': `<svg viewBox="0 0 100 100"><g fill="${colors.whitePiece}" stroke="${colors.blackPiece}" stroke-width="3"><rect x="45" y="10" width="10" height="25" /><rect x="35" y="20" width="30" height="10" /><path d="M 35 30 L 65 30 L 55 75 L 45 75 Z" /><rect x="30" y="75" width="40" height="15" rx="5" /></g></svg>`,
        'b_pawn': `<svg viewBox="0 0 100 100"><g fill="${colors.blackPiece}" stroke="${colors.whitePiece}" stroke-width="3"><circle cx="50" cy="30" r="20" /><rect x="35" y="45" width="30" height="40" rx="10" /><rect x="25" y="80" width="50" height="10" rx="5" /></g></svg>`,
        'b_rook': `<svg viewBox="0 0 100 100"><g fill="${colors.blackPiece}" stroke="${colors.whitePiece}" stroke-width="3"><rect x="25" y="20" width="50" height="15" rx="5" /><rect x="35" y="35" width="30" height="50" rx="5" /><rect x="20" y="80" width="60" height="10" rx="5" /></g></svg>`,
        'b_knight': `<svg viewBox="0 0 100 100"><g fill="${colors.blackPiece}" stroke="${colors.whitePiece}" stroke-width="3"><path d="M 40 20 C 20 20, 20 60, 40 60 L 50 80 L 30 80 L 25 90 L 75 90 L 70 80 L 50 80 L 60 50 C 80 50, 80 20, 60 20 Z" /><circle cx="60" cy="35" r="5" fill="${colors.whitePiece}"/></g></svg>`,
        'b_bishop': `<svg viewBox="0 0 100 100"><g fill="${colors.blackPiece}" stroke="${colors.whitePiece}" stroke-width="3"><path d="M 50 15 A 25 25 0 0 1 50 65 A 25 25 0 0 1 50 15 Z" /><rect x="40" y="60" width="20" height="25" rx="5" /><rect x="30" y="80" width="40" height="10" rx="5" /></g></svg>`,
        'b_queen': `<svg viewBox="0 0 100 100"><g fill="${colors.blackPiece}" stroke="${colors.whitePiece}" stroke-width="3"><circle cx="50" cy="20" r="10" /><path d="M 30 30 L 70 30 L 60 70 L 40 70 Z" /><rect x="35" y="70" width="30" height="15" rx="5" /><rect x="25" y="85" width="50" height="10" rx="5" /></g></svg>`,
        'b_king': `<svg viewBox="0 0 100 100"><g fill="${colors.blackPiece}" stroke="${colors.whitePiece}" stroke-width="3"><rect x="45" y="10" width="10" height="25" /><rect x="35" y="20" width="30" height="10" /><path d="M 35 30 L 65 30 L 55 75 L 45 75 Z" /><rect x="30" y="75" width="40" height="15" rx="5" /></g></svg>`,
    };

    /**
     * Initializes the game board, state, and renders it.
     */
    function initializeGame() {
        const initialBoard = [
            ['b_rook', 'b_knight', 'b_bishop', 'b_queen', 'b_king', 'b_bishop', 'b_knight', 'b_rook'],
            ['b_pawn', 'b_pawn', 'b_pawn', 'b_pawn', 'b_pawn', 'b_pawn', 'b_pawn', 'b_pawn'],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            ['w_pawn', 'w_pawn', 'w_pawn', 'w_pawn', 'w_pawn', 'w_pawn', 'w_pawn', 'w_pawn'],
            ['w_rook', 'w_knight', 'w_bishop', 'w_queen', 'w_king', 'w_bishop', 'w_knight', 'w_rook'],
        ];
        boardState = JSON.parse(JSON.stringify(initialBoard)); // Deep copy
        currentPlayer = 'white';
        selectedPiece = null;
        validMoves = [];
        isGameOver = false;
        whiteKingPosition = { row: 7, col: 4 };
        blackKingPosition = { row: 0, col: 4 };
        drawBoard();
        updateTurnIndicator();
    }
    
    window.resetGame = function() {
        winModal.classList.add('hidden');
        winModal.children[0].classList.add('scale-90');
        initializeGame();
    }

    /**
     * Renders the entire chessboard based on the current boardState.
     */
    function drawBoard() {
        boardElement.innerHTML = '';
        for (let row = 0; row < 8; row++) {
            for (let col = 0; col < 8; col++) {
                const square = document.createElement('div');
                square.classList.add('square');
                square.style.backgroundColor = (row + col) % 2 === 0 ? colors.whiteSquare : colors.blackSquare;
                square.dataset.row = row;
                square.dataset.col = col;

                const pieceName = boardState[row][col];
                if (pieceName) {
                    const pieceElement = document.createElement('div');
                    pieceElement.classList.add('piece');
                    pieceElement.innerHTML = pieceSVG[pieceName];
                    pieceElement.dataset.piece = pieceName;
                    square.appendChild(pieceElement);
                }
                
                boardElement.appendChild(square);
            }
        }
        addSquareClickListeners();
    }
    
    function addSquareClickListeners() {
        const squares = document.querySelectorAll('.square');
        squares.forEach(square => {
            square.addEventListener('click', () => handleSquareClick(square));
        });
    }

    /**
     * Main logic handler for when a square is clicked.
     */
    function handleSquareClick(square) {
        if (isGameOver) return;
        
        // Start Tone.js audio context on first user interaction
        if (Tone.context.state !== 'running') {
            Tone.start();
        }

        const row = parseInt(square.dataset.row);
        const col = parseInt(square.dataset.col);
        const piece = boardState[row][col];

        // If a piece is already selected, check if this is a valid move
        if (selectedPiece) {
            const is_valid_move = validMoves.some(move => move.row === row && move.col === col);
            if (is_valid_move) {
                movePiece(selectedPiece.row, selectedPiece.col, row, col);
            } else {
                // If not a valid move, deselect the piece, unless it's a click on another of their own pieces
                clearHighlights();
                selectedPiece = null;
                // If the new square has a piece of the current player, select it
                if (piece && piece.startsWith(currentPlayer.charAt(0))) {
                    selectPiece(row, col, piece);
                }
            }
        } else if (piece && piece.startsWith(currentPlayer.charAt(0))) {
            // If no piece is selected, and a valid piece is clicked, select it
            selectPiece(row, col, piece);
        }
    }

    /**
     * Selects a piece, highlights it, and shows its valid moves.
     */
    function selectPiece(row, col, piece) {
        clearHighlights();
        selectedPiece = { row, col, piece };
        validMoves = getValidMovesForPiece(row, col, piece);
        
        // Filter moves to ensure they don't leave the king in check
        const kingColor = currentPlayer;
        validMoves = validMoves.filter(move => {
            // Simulate the move
            const originalPiece = boardState[move.row][move.col];
            boardState[move.row][move.col] = piece;
            boardState[row][col] = null;
            let kingPos = (kingColor === 'white') ? whiteKingPosition : blackKingPosition;
            if (piece.endsWith('king')) {
                kingPos = {row: move.row, col: move.col};
            }

            const inCheck = isKingInCheck(kingColor, kingPos);

            // Revert the move
            boardState[row][col] = piece;
            boardState[move.row][move.col] = originalPiece;
            
            return !inCheck;
        });

        const pieceElement = boardElement.children[row * 8 + col].querySelector('.piece');
        if(pieceElement) pieceElement.classList.add('selected');
        
        showValidMoveDots();
    }

    /**
     * Moves a piece from one square to another, updating the state and view.
     */
    function movePiece(fromRow, fromCol, toRow, toCol) {
        const piece = boardState[fromRow][fromCol];
        const capturedPiece = boardState[toRow][toCol];

        // Animate the move
        const fromSquareRect = boardElement.children[fromRow * 8 + fromCol].getBoundingClientRect();
        const toSquareRect = boardElement.children[toRow * 8 + toCol].getBoundingClientRect();
        const pieceElement = boardElement.children[fromRow * 8 + fromCol].querySelector('.piece');

        const dx = toSquareRect.left - fromSquareRect.left;
        const dy = toSquareRect.top - fromSquareRect.top;
        pieceElement.style.transform = `translate(${dx}px, ${dy}px)`;

        // Play sound
        if (capturedPiece) {
            captureSound.triggerAttackRelease("A3", "8n");
        } else {
            moveSound.triggerAttackRelease("C4", "8n");
        }

        // After animation, update the board
        setTimeout(() => {
            boardState[toRow][toCol] = piece;
            boardState[fromRow][fromCol] = null;
            
            // Update king's position if it moved
            if (piece.endsWith('king')) {
                if(currentPlayer === 'white') {
                    whiteKingPosition = { row: toRow, col: toCol };
                } else {
                    blackKingPosition = { row: toRow, col: toCol };
                }
            }
            
            drawBoard(); // Redraw to finalize the move
            switchPlayer();
        }, 300); // Same duration as the CSS transition

        clearHighlights();
        selectedPiece = null;
    }
    
    /**
     * Switches the current player and checks for check/checkmate.
     */
    function switchPlayer() {
        currentPlayer = (currentPlayer === 'white') ? 'black' : 'white';
        updateTurnIndicator();

        const kingPos = (currentPlayer === 'white') ? whiteKingPosition : blackKingPosition;
        if (isKingInCheck(currentPlayer, kingPos)) {
            checkSound.triggerAttackRelease("G5", "8n");
            checkIndicator.textContent = `${currentPlayer.charAt(0).toUpperCase() + currentPlayer.slice(1)} is in Check!`;
            
            // Highlight king in check
            const kingSquare = boardElement.children[kingPos.row * 8 + kingPos.col];
            kingSquare.classList.add('in-check');

            if (isCheckmate(currentPlayer)) {
                gameOver((currentPlayer === 'white') ? 'Black' : 'White');
            }
        } else {
            checkIndicator.textContent = '';
            // Also check for stalemate
             if (isStalemate(currentPlayer)) {
                gameOver(null); // No winner for stalemate
            }
        }
    }

    /**
     * Gets all valid moves for a given piece at a specific position.
     */
    function getValidMovesForPiece(row, col, piece) {
        const type = piece.substring(2);
        const color = piece.startsWith('w') ? 'white' : 'black';
        let moves = [];

        switch (type) {
            case 'pawn': moves = getPawnMoves(row, col, color); break;
            case 'rook': moves = getRookMoves(row, col); break;
            case 'knight': moves = getKnightMoves(row, col); break;
            case 'bishop': moves = getBishopMoves(row, col); break;
            case 'queen': moves = getQueenMoves(row, col); break;
            case 'king': moves = getKingMoves(row, col); break;
        }
        
        // Filter out moves that would land on a piece of the same color
        const opponentColor = (color === 'white') ? 'b' : 'w';
        return moves.filter(move => {
            const targetPiece = boardState[move.row][move.col];
            return !targetPiece || !targetPiece.startsWith(color.charAt(0));
        });
    }

    // --- Piece-specific Move Logic ---
    function getPawnMoves(row, col, color) {
        const moves = [];
        const direction = (color === 'white') ? -1 : 1;
        const startRow = (color === 'white') ? 6 : 1;

        // 1. One step forward
        if (isValid(row + direction, col) && !boardState[row + direction][col]) {
            moves.push({ row: row + direction, col });
            // 2. Two steps forward from start
            if (row === startRow && !boardState[row + 2 * direction][col]) {
                moves.push({ row: row + 2 * direction, col });
            }
        }
        // 3. Capture diagonally
        const opponent = (color === 'white') ? 'b' : 'w';
        [-1, 1].forEach(dCol => {
            if (isValid(row + direction, col + dCol) && boardState[row + direction][col + dCol]?.startsWith(opponent)) {
                moves.push({ row: row + direction, col: col + dCol });
            }
        });

        return moves;
    }

    function getRookMoves(row, col) { return getSlidingMoves(row, col, [[-1, 0], [1, 0], [0, -1], [0, 1]]); }
    function getBishopMoves(row, col) { return getSlidingMoves(row, col, [[-1, -1], [-1, 1], [1, -1], [1, 1]]); }
    function getQueenMoves(row, col) { return getSlidingMoves(row, col, [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [-1, 1], [1, -1], [1, 1]]); }

    function getSlidingMoves(row, col, directions) {
        const moves = [];
        const pieceColor = boardState[row][col]?.charAt(0);
        directions.forEach(([dr, dc]) => {
            for (let i = 1; i < 8; i++) {
                const newRow = row + i * dr;
                const newCol = col + i * dc;
                if (!isValid(newRow, newCol)) break;
                const targetPiece = boardState[newRow][newCol];
                if (targetPiece) {
                    if (!targetPiece.startsWith(pieceColor)) {
                        moves.push({ row: newRow, col: newCol }); // Can capture
                    }
                    break; // Blocked
                }
                moves.push({ row: newRow, col: newCol });
            }
        });
        return moves;
    }

    function getKnightMoves(row, col) {
        const moves = [];
        const directions = [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]];
        directions.forEach(([dr, dc]) => {
            const newRow = row + dr;
            const newCol = col + dc;
            if (isValid(newRow, newCol)) {
                moves.push({ row: newRow, col: newCol });
            }
        });
        return moves;
    }

    function getKingMoves(row, col) {
        const moves = [];
        const directions = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]];
        directions.forEach(([dr, dc]) => {
            const newRow = row + dr;
            const newCol = col + dc;
            if (isValid(newRow, newCol)) {
                moves.push({ row: newRow, col: newCol });
            }
        });
        return moves;
    }

    // --- Check and Checkmate Logic ---
    function isKingInCheck(kingColor, kingPos) {
        const opponentColor = (kingColor === 'white') ? 'black' : 'white';
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                const piece = boardState[r][c];
                if (piece && piece.startsWith(opponentColor.charAt(0))) {
                    const moves = getValidMovesForPiece(r, c, piece);
                    if (moves.some(move => move.row === kingPos.row && move.col === kingPos.col)) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
    
    function isCheckmate(kingColor) {
        // King is in check, check if any move can get it out of check
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                const piece = boardState[r][c];
                if (piece && piece.startsWith(kingColor.charAt(0))) {
                    const moves = getValidMovesForPiece(r, c, piece);
                    for (const move of moves) {
                        // Simulate the move
                        const originalPiece = boardState[move.row][move.col];
                        boardState[move.row][move.col] = piece;
                        boardState[r][c] = null;
                        
                        let kingPos = (kingColor === 'white') ? whiteKingPosition : blackKingPosition;
                         if (piece.endsWith('king')) {
                             kingPos = {row: move.row, col: move.col};
                         }
                        
                        const stillInCheck = isKingInCheck(kingColor, kingPos);

                        // Revert the move
                        boardState[r][c] = piece;
                        boardState[move.row][move.col] = originalPiece;

                        if (!stillInCheck) {
                            return false; // Found a move to escape check
                        }
                    }
                }
            }
        }
        return true; // No moves escape check
    }
    
    function isStalemate(playerColor) {
        if (isKingInCheck(playerColor, playerColor === 'white' ? whiteKingPosition : blackKingPosition)) {
            return false; // It's checkmate, not stalemate
        }
        // Check if the player has any legal moves
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                const piece = boardState[r][c];
                if (piece && piece.startsWith(playerColor.charAt(0))) {
                     const moves = getValidMovesForPiece(r, c, piece);
                      for (const move of moves) {
                        // Simulate the move to see if it's legal (doesn't put king in check)
                        const originalPiece = boardState[move.row][move.col];
                        boardState[move.row][move.col] = piece;
                        boardState[r][c] = null;
                        
                        let kingPos = (playerColor === 'white') ? whiteKingPosition : blackKingPosition;
                        if (piece.endsWith('king')) {
                            kingPos = {row: move.row, col: move.col};
                        }
                        
                        const inCheck = isKingInCheck(playerColor, kingPos);

                        // Revert the move
                        boardState[r][c] = piece;
                        boardState[move.row][move.col] = originalPiece;

                        if (!inCheck) {
                            return false; // Found a legal move
                        }
                    }
                }
            }
        }
        return true; // No legal moves found
    }

    // --- UI and Helper Functions ---
    function isValid(row, col) { return row >= 0 && row < 8 && col >= 0 && col < 8; }
    
    function showValidMoveDots() {
        validMoves.forEach(move => {
            const square = boardElement.children[move.row * 8 + move.col];
            const dot = document.createElement('div');
            dot.classList.add('move-dot');
            square.appendChild(dot);
        });
    }

    function clearHighlights() {
        document.querySelectorAll('.piece.selected').forEach(p => p.classList.remove('selected'));
        document.querySelectorAll('.move-dot').forEach(dot => dot.remove());
        document.querySelectorAll('.square.in-check').forEach(s => s.classList.remove('in-check'));
    }
    
    function updateTurnIndicator() {
        turnIndicator.textContent = `${currentPlayer.charAt(0).toUpperCase() + currentPlayer.slice(1)}'s Turn`;
        turnIndicator.style.color = currentPlayer === 'white' ? 'var(--white-piece)' : 'var(--black-piece)';
        // A little visual pop for the text
        turnIndicator.style.textShadow = currentPlayer === 'white' ? '1px 1px 2px var(--black-piece)' : '1px 1px 2px var(--white-piece)';
    }
    
    function gameOver(winner) {
        isGameOver = true;
        if (winner) {
             winMessage.textContent = `${winner} Team Wins!`;
        } else {
             winMessage.textContent = "Stalemate! It's a Draw!";
        }
        winModal.classList.remove('hidden');
        setTimeout(() => {
             winModal.children[0].classList.remove('scale-90');
        }, 50); // Small delay to allow transition
    }

    // --- Start the game ---
    initializeGame();

</script>
</body>
</html>
